<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultimate Chaos Snake üêçüí•</title>
<style>
  body {
    margin: 0;
    background: black;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    color: white;
    font-family: "Comic Sans MS", cursive, sans-serif;
  }
  canvas {
    background: #111;
    border: 3px solid #0f0;
    box-shadow: 0 0 20px #0f0;
  }
  #score {
    margin-bottom: 10px;
    font-size: 24px;
  }
  #codeBox {
    margin-top: 10px;
    padding: 6px;
    font-size: 16px;
    border: 2px solid #0f0;
    background: #111;
    color: #0f0;
    width: 200px;
    text-align: center;
  }
  .shake {
    animation: shake 0.3s;
  }
  @keyframes shake {
    0% { transform: translate(5px, 5px); }
    20% { transform: translate(-5px, -5px); }
    40% { transform: translate(-5px, 5px); }
    60% { transform: translate(5px, -5px); }
    80% { transform: translate(-5px, 5px); }
    100% { transform: translate(0, 0); }
  }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="game" width="400" height="400"></canvas>
<input id="codeBox" placeholder="Enter Code... (press Enter)">
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const codeBox = document.getElementById('codeBox');
const grid = 20;
let snake = [{x: 200, y: 200}];
let dx = grid, dy = 0;
let apples = [{x: randPos(), y: randPos()}];
let score = 0;
let eaten = 0;
let autoPlay = false;
let winMode = false;
let speed = 100;
let loopId;

function randPos() { return Math.floor(Math.random()*(canvas.width/grid))*grid; }

function drawSnake() {
  ctx.fillStyle = autoPlay || winMode ? randomColor() : 'lime';
  snake.forEach(s=>ctx.fillRect(s.x,s.y,grid,grid));
}

function drawApples() {
  ctx.fillStyle = 'red';
  apples.forEach(a=>ctx.fillRect(a.x,a.y,grid,grid));
}

function randomColor() {
  const colors = ['red','orange','yellow','lime','cyan','blue','magenta'];
  return colors[Math.floor(Math.random()*colors.length)];
}

function flashBG() {
  document.body.style.background = randomColor();
  setTimeout(()=>document.body.style.background = '#000',150);
}

function shake() {
  document.body.classList.add('shake');
  setTimeout(()=>document.body.classList.remove('shake'),300);
}

function spawnApple(){ return {x:randPos(),y:randPos()}; }

function update() {
  const head = {x: snake[0].x + dx, y: snake[0].y + dy};
  snake.unshift(head);

  // Eat apples
  let ate = false;
  for(let i=apples.length-1;i>=0;i--){
    if(head.x===apples[i].x && head.y===apples[i].y){
      ate = true;
      apples.splice(i,1);
      eaten++;
      score+=10;
      scoreEl.textContent = 'Score: '+score;
      flashBG();
      shake();
      if(eaten%4===0) for(let j=0;j<3;j++) apples.push(spawnApple());
      apples.push(spawnApple());
    }
  }
  if(!ate) snake.pop();

  // Collision check
  if(head.x<0||head.x>=canvas.width||head.y<0||head.y>=canvas.height||
    snake.slice(1).some(s=>s.x===head.x&&s.y===head.y)){
    if(winMode) return; // Ignore in win mode
    alert('Game Over! Score: '+score);
    document.location.reload();
  }

  // Victory
  if(snake.length>(canvas.width/grid)*(canvas.height/grid)*0.7 && !winMode){
    alert('VICTORY MODE!');
    winMode=true;
    fireworkMode();
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawSnake();
  drawApples();
}

// Key controls
document.addEventListener('keydown', e=>{
  if(autoPlay||winMode) return;
  if(e.key==='ArrowLeft'&&dx===0){dx=-grid;dy=0;}
  else if(e.key==='ArrowUp'&&dy===0){dx=0;dy=-grid;}
  else if(e.key==='ArrowRight'&&dx===0){dx=grid;dy=0;}
  else if(e.key==='ArrowDown'&&dy===0){dx=0;dy=grid;}
});

// Code box
codeBox.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    if(codeBox.value.trim().toUpperCase()==='WINALL'){
      autoPlay=true;
      winMode=true;
      setTimeout(autoCompleteWin,300);
    }
    codeBox.value='';
  }
});

// Smarter autopilot (avoids collisions)
function autoMove(){
  if(!autoPlay||winMode) return;
  let head=snake[0];
  let target=apples[0];
  let nextX=head.x, nextY=head.y;
  if(head.x<target.x) nextX+=grid;
  else if(head.x>target.x) nextX-=grid;
  else if(head.y<target.y) nextY+=grid;
  else if(head.y>target.y) nextY-=grid;

  // avoid hitting itself: try alternate path
  if(snake.some(s=>s.x===nextX&&s.y===nextY)){
    const dirs=[[grid,0],[-grid,0],[0,grid],[0,-grid]];
    for(let [nx,ny] of dirs){
      if(!snake.some(s=>s.x===head.x+nx&&s.y===head.y+ny) &&
         head.x+nx>=0&&head.x+nx<canvas.width&&head.y+ny>=0&&head.y+ny<canvas.height){
        dx=nx; dy=ny;
        return;
      }
    }
  }
  dx=nextX-head.x;
  dy=nextY-head.y;
}

// Auto win sequence
function autoCompleteWin(){
  // fill screen visually for fun
  for(let y=0;y<canvas.height;y+=grid){
    for(let x=0;x<canvas.width;x+=grid){
      snake.push({x,y});
    }
  }
  winMode=true;
  fireworkMode();
}

// Firework victory
function fireworkMode(){
  clearInterval(loopId);
  let sparks=[];
  const interval=setInterval(()=>{
    ctx.fillStyle='rgba(0,0,0,0.1)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    sparks.push({x:randPos(),y:randPos(),r:Math.random()*5+2,color:randomColor()});
    for(let s of sparks){
      ctx.beginPath();
      ctx.fillStyle=s.color;
      ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
      ctx.fill();
    }
  },50);
}

function gameLoop(){
  if(eaten>=3) autoPlay=true;
  autoMove();
  update();
}

loopId=setInterval(gameLoop,speed);
</script>
</body>
</html>
